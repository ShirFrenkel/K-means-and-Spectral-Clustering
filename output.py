import numpy as np
import matplotlib.pyplot as plt
from matplotlib import cm
import config
from point_cluster_map import point_cluster_map


def write_data_file(points, cluster_labels):
    """
            :param points: nXd numpy array of the samples generated by make_blobs.
            :param cluster_labels: numpy array of the integer labels for cluster membership of each sample..
            @post: writing to data.txt in the format mentioned in the assigment.
    """

    n = cluster_labels.shape[0]     # number of points
    points_list = points.tolist()   # converting to list of lists in order to handle floats and ints.
    # the following statement will convert each poing to a string and append to it the cluster label.
    as_strings = [','.join([str(num) for num in points_list[i]]) + ',' + str(cluster_labels[i]) for i in range(n)]
    output = '\n'.join(as_strings)
    f = open(config.DATA_FILE_NAME, "w")
    f.write(output)
    f.close()
    #TODO not sure what is the accuracy level we need for points


def write_clusters_file(spectral_tags, kmeans_tags, k):
    """
        :param spectral_tags: list of cluster classification by the Normalized Spectral Clustering algorithm.
        :param kmeans_tags: list of cluster classification by the kmeans++ algorithm.
        :param k: the number of clusters to which we classified our date.
        @post: writing to clusters.txt in the format mentioned in the assigment.
    """
    spectral_for_print = convert_cluster_oriented(spectral_tags, k)
    kmeans_for_print = convert_cluster_oriented(kmeans_tags, k)
    string_to_print = str(k)
    for cluster in spectral_for_print:
        string_to_print += ('\n' + cluster)
    for cluster in kmeans_for_print:
        string_to_print += ('\n' + cluster)
    f = open(config.CLUSTERS_FILE_NAME, "w")
    f.write(string_to_print)
    f.close()


def convert_cluster_oriented(cluster_tags, k):
    """
        :param cluster_tags: an array of n ints where cluster_tags[i] is the cluster number point i belongs to.
        :param k: the number of clusters.
        :return: list of strings in which converted[i] represents the points belonging to cluster i separated by ','.
    """
    converted = [[] for i in range(k)]
    for i in range(len(cluster_tags)):
        converted[cluster_tags[i]].append(str(i))
    converted = [','.join([num for num in cluster]) for cluster in converted]
    return converted


def jaccard_measure(cluster_labels, algo_cluster_tags, k):
    """
        :param cluster_labels: the cluster labels from make_blobs method - our truth standard.
        :param algo_cluster_tags: an algorithms output of cluster classification.
        :param k: the number of clusters.
        :return: the relation between the number of intersecting pairs in both cases and the union of pairs.
    """

    algo_list_clusters = to_clusters_list(algo_cluster_tags, k)
    algorithm_pairs, intersecting_pairs = count_pairs(algo_list_clusters, cluster_labels)
    labels_pairs = float(cluster_labels_pairs(cluster_labels, k))
    jaccard = intersecting_pairs / (algorithm_pairs + labels_pairs - intersecting_pairs)
    return jaccard


def to_clusters_list(cluster_tags, k):
    """
    helper function to jaccard_measure
        :param cluster_tags: an array of n ints where cluster_tags[i] is the cluster number point i belongs to.
        :param k: the number of clusters.
        :return: list of lists in which converted[i] is a list of the points belonging to cluster i.
    """
    converted = [[] for i in range(k)]
    for i in range(len(cluster_tags)):
        converted[cluster_tags[i]].append(i)
    return converted


def count_pairs(clusters_list, cluster_labels):
    """
    helper function to jaccard_measure
        :param clusters_list: list of lists containing the cluster classification by (one) of our algorithms.
        :param cluster_labels: the classification to clusters by which the data was generated.
        :return  algorithm_pairs: num of pairs {i, j} such that points i, j belong to the same cluster by the algorithm.
        :return intersecting_pairs: number of pairs {i, j} such that points i, j belong to the same cluster
                                    by the algorithm and by the make_blobs.
    """
    algorithm_pairs = 0
    intersecting_pairs = 0
    for points_in_cluster in clusters_list:
        for i in range(len(points_in_cluster)):
            for j in range(i+1, len(points_in_cluster)):
                algorithm_pairs += 1
                if cluster_labels[points_in_cluster[i]] == cluster_labels[points_in_cluster[j]]:
                    intersecting_pairs += 1
    return algorithm_pairs, intersecting_pairs


def cluster_labels_pairs(cluster_labels, k):
    """
    helper function to jaccard_measure
        :param cluster_labels: an array of n ints where cluster_tags[i] is the cluster number point i belongs to.
        :param k: the number of clusters by which the data was generated.
        :return  pairs_num: num of pairs {i, j} such that points i, j belong to the same cluster.
    """
    points_in_cluster = np.zeros((k,), dtype=int)
    pairs_num = 0
    for num in cluster_labels:
        points_in_cluster[num] += 1
    for cluster in points_in_cluster:
        pairs_num += (cluster**2 - cluster) / 2
    return pairs_num


def visualize(points, k_original, k_algo, maps_lst):
    """
    :param points: ndarry, shape(points) = (n,d) (n points with d dimensions)
    :param k_original: amount of centers the points were generated from
    :param k_algo: k that was used for both algorithms
    :param maps_lst: lst of point_cluster_map objects matching the input's points
    @post: creates clusters.pdf with axis for each map in maps_lst ordered horizontally by the maps_lst order
    """
    # TODO ? change to T order
    dim = points.shape[1]
    x = points[:, 0]
    y = points[:, 1]
    z = points[:, 2] if dim == 3 else None
    projection = '3d' if dim == 3 else None

    fig, ax = plt.subplots(1, len(maps_lst), subplot_kw=dict(projection=projection))  # subplots horizontally

    colors = [cm.rainbow(i) for i in np.linspace(0, 1, k_algo)]

    for i in range(len(maps_lst)):
        color = [colors[cluster] for cluster in maps_lst[i].map]  # color for each point by it's cluster
        ax[i].scatter(x, y, z, c=color)
        ax[i].set_title(maps_lst[i].name)

    plt.figtext(0.3, 0, "insert an informative desc as requested!!!\n\n****")  # TODO, maybe use subtitle instead of this shit
    #plt.show()
    plt.savefig("clusters.pdf")


# test visualize
spec = point_cluster_map("Normalized Spectral Clustering", [0,1,0,1,0])
kmeans = point_cluster_map("K-means", [2,2,2,1,1])
shir_algo = point_cluster_map("another algo", [0,0,0,0,0])
lst_map = [spec, kmeans, shir_algo]

A = np.array([[j for j in range(i,i+3)]for i in range(0,15,3)], np.float64)
visualize(A,3,3,lst_map)

B = np.array([[j for j in range(i,i+2)]for i in range(0,10,2)], np.float64)
visualize(B,3,3,lst_map)
